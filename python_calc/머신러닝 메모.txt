여러 킥보드를 비교해서 각 킥보드 별 선호도를 측정하고, 상위 3개를 뽑아야 함

# 외부 시스템과 커뮤니케이션할 때 고려해야할 점들
- user_taste는 어떻게 주고받을지 (업데이트도 가능해야 함)
- get_kickboard_info() 구현 방법 (DB, 파일, 백엔드 요청 등)


# 프로그램 진행 프로세스
1. 현재 위치와 도착 위치 받기 (백엔드에서 머신러닝 모듈 호출할 때 인자로 넘겨주기)
2. 전동킥보드 후보군 선택하기 (일정 거리 이내 모두 가져오기)
3. 각 전동킥보드 별 연산 프로세스 수행 (위쪽 '연산 프로세스' 참고)
4. 각 전동킥보드 별 연산 결과 (예상 가격, 킥보드 시간, 걷는 시간) 반환
5. 선택한 전동킥보드 결과 토대로 user_taste 업데이트


# 킥보드 하나에 대한 연산 프로세스
walk_distence, kickboard_distence = calc_distence(user_pos, kickboard_pos, arrival_pos) // 알아서 계산하겠지
if(kickboard_distence > max_kickboard_distence) continue; // 배터리 부족해서 최대 이동거리보다 멀리 가야한다면 이 킥보드는 계산 패스, 후보군에서 제외
walk_time = walk_distence / (4km/h)
kickboard_time = kickboard_distence / kickboard_speed
price = calc_price(company, kickboard_time)
preference = - [price, kickboard_time, walk_time] * user_taste // 가격, 킥보드시간, 걷기시간 모두 작을수록 좋기 때문에 마이너스 붙음


# sub-functions

## input arguments
- user_pos
- arrival_pos
- user_taste // 합이 1이 되도록 정규화되어 있음

## calc_price(company, kickboard_time)
gcooter: 450 + 150 t
xingxing: min(1000, 500 + 100 t)
beam: 600 + 180 t

## calc_distence()

## get_kickboard_speed()

## get_kickboard_info() // 실제로는 어떻게 가져올건지? DB? 파일? 백엔드 요청?
- kickboard_pos
- max_kickboard_distence


# 사용되는 변수들, variables

## input: user data
- user_taste
- user_pos
- arrival_pos
## input: kickboard data
- kickboard_pos
- max_kickboard_distence
- company

## local variable
- walk_distence
- walk_time
- kickboard_distence
- kickboard_time
- kickboard_speed

## output
- price
- kickboard_time
- walk_time
- preference
- 업데이트된 user_taste

